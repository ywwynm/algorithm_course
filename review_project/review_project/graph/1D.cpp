///*
//  1D:仙岛求药
//  总时间限制: 1000ms 内存限制: 65536kB
//
//  描述
//  少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，
//  发现仙药摆在了迷阵的深处。迷阵由M×N个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，
//  显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。
//  
//  输入
//  输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始，两者均不大于20。M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含N个字符,不同字符分别代表不同含义: 
//  1)	‘@’：少年李逍遥所在的位置；
//  2)	‘.’：可以安全通行的方格；
//  3)	‘#’：有怪物的方格；
//  4)	‘*’：仙药所在位置。
//  当在一行中读入的是两个零时，表示输入结束。
//
//  输出
//  对于每组测试数据，分别输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 -1。
//
//  样例输入
//  8 8
//  .@##...#
//  #....#.#
//  #.#.##..
//  ..#.###.
//  #.#...#.
//  ..###.#.
//  ...#.*..
//  .#...###
//  6 5
//  .*.#.
//  .#...
//  ..##.
//  .....
//  .#...
//  ....@
//  9 6
//  .#..#. 
//  .#.*.# 
//  .####. 
//  ..#... 
//  ..#... 
//  ..#... 
//  ..#... 
//  #.@.## 
//  .#..#. 
//  0 0
//
//  样例输出
//  10
//  8
//  -1
//
//*/
//
//
//#include <iostream>
//#include <cstring>
//#include <queue>
//
//using namespace std;
//
//char maze[20][20], ceq[20][20], dis[20][20];
//int M, N;
//int sx, sy;
//
//int solve() {
//  queue<pair<int, int> > q;
//  q.push(make_pair(sx, sy));
//  memset(ceq, true, sizeof(ceq));
//  ceq[sx][sy] = false;
//  dis[sx][sy] = 0;
//  while (!q.empty()) {
//    pair<int, int> p = q.front(); q.pop();
//    int i = p.first, j = p.second;
//    char c = maze[i][j];
//    if (c == '*') {
//      return dis[i][j];
//    } else if (c == '@' || c == '.') {
//      int nI[4] = { i - 1, i,    i + 1, i     };
//      int nJ[4] = { j,     j - 1,j,     j + 1 };
//      for (int k = 0; k < 4; k++) {
//        int ni = nI[k], nj = nJ[k];
//        if (ni >= 0 && nj >= 0 && ni < M && nj < N && ceq[ni][nj]) {
//          q.push(make_pair(ni, nj));
//          dis[ni][nj] = dis[i][j] + 1;
//          ceq[ni][nj] = false;
//        }
//      }
//    }
//  }
//  return -1;
//}
//
//int main() {
//  while (cin >> M >> N) {
//    if (M == 0 && N == 0) break;
//    sx = -1; sy = -1;
//    for (int i = 0; i < M; i++) for (int j = 0; j < N; j++) {
//      cin >> maze[i][j];
//      if (maze[i][j] == '@') {
//        sx = i; sy = j;
//      }
//    }
//    if (sx == -1 && sy == -1) cout << -1 << endl;
//    else cout << solve() << endl;
//  }
//  return 0;
//}
//
//
//
//
//
//
//
//
//
//
//
//
//
//
///*
//  坑: x和y，i和j，维度问题（第i行j列的坐标是i,j么？边界分别是小于M还是小于N？），分清楚。。。
//*/
